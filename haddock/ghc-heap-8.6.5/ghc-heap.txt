-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions for walking GHC's heap
--   
--   This package provides functions for walking the GHC heap data
--   structures and retrieving information about those data structures.
@package ghc-heap
@version 8.6.5

module GHC.Exts.Heap.ClosureTypes
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
N_CLOSURE_TYPES :: ClosureType

-- | Return the size of the closures header in words
closureTypeHeaderSize :: ClosureType -> Int
instance GHC.Show.Show GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Classes.Ord GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Classes.Eq GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Enum.Enum GHC.Exts.Heap.ClosureTypes.ClosureType

module GHC.Exts.Heap.Constants
wORD_SIZE :: Int
tAG_MASK :: Int
wORD_SIZE_IN_BITS :: Int

module GHC.Exts.Heap.InfoTable.Types

-- | This is a somewhat faithful representation of an info table. See
--   <a>http://hackage.haskell.org/trac/ghc/browser/includes/rts/storage/InfoTables.h</a>
--   for more details on this data structure.
data StgInfoTable
StgInfoTable :: Maybe EntryFunPtr -> HalfWord -> HalfWord -> ClosureType -> HalfWord -> Maybe ItblCodes -> StgInfoTable
[entry] :: StgInfoTable -> Maybe EntryFunPtr
[ptrs] :: StgInfoTable -> HalfWord
[nptrs] :: StgInfoTable -> HalfWord
[tipe] :: StgInfoTable -> ClosureType
[srtlen] :: StgInfoTable -> HalfWord
[code] :: StgInfoTable -> Maybe ItblCodes
type EntryFunPtr = FunPtr (Ptr () -> IO (Ptr ()))
type HalfWord = Word32
type ItblCodes = Either [Word8] [Word32]
instance GHC.Show.Show GHC.Exts.Heap.InfoTable.Types.StgInfoTable

module GHC.Exts.Heap.InfoTable

-- | Size in bytes of a standard InfoTable
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

module GHC.Exts.Heap.InfoTableProf
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

module GHC.Exts.Heap.Closures
type Closure = GenClosure Box

-- | This is the representation of a Haskell value on the heap. It reflects
--   <a>http://hackage.haskell.org/trac/ghc/browser/includes/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by the type to store references in.
--   Usually this is a <a>Box</a> with the type synonym <a>Closure</a>.
--   
--   All Heap objects have the same basic layout. A header containing a
--   pointer to the info table and a payload with various fields. The
--   <tt>info</tt> field below always refers to the info table pointed to
--   by the header. The remaining fields are the payload.
--   
--   See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects</a>
--   for more information.
data GenClosure b

-- | A data constructor
ConstrClosure :: !StgInfoTable -> ![b] -> ![Word] -> !String -> !String -> !String -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | Package name
[pkg] :: GenClosure b -> !String

-- | Module name
[modl] :: GenClosure b -> !String

-- | Constructor name
[name] :: GenClosure b -> !String

-- | A function
FunClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk, an expression not obviously in head normal form
ThunkClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk which performs a simple selection operation
SelectorClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to the object being selected from
[selectee] :: GenClosure b -> !b

-- | An unsaturated function application
PAPClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A function application
APClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A suspended thunk evaluation
APStackClosure :: !StgInfoTable -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A pointer to another closure, introduced when a thunk is updated to
--   point at its value
IndClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A byte-code object (BCO) which can be interpreted by GHC's byte-code
--   interpreter (e.g. as used by GHCi)
BCOClosure :: !StgInfoTable -> !b -> !b -> !b -> !HalfWord -> !HalfWord -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A pointer to an ArrWords of instructions
[instrs] :: GenClosure b -> !b

-- | A pointer to an ArrWords of literals
[literals] :: GenClosure b -> !b

-- | A pointer to an ArrWords of byte code objects
[bcoptrs] :: GenClosure b -> !b

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | The size of this BCO in words
[size] :: GenClosure b -> !HalfWord

-- | An StgLargeBitmap describing the pointerhood of its args/free vars
[bitmap] :: GenClosure b -> ![Word]

-- | A thunk under evaluation by another thread
BlackholeClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A <tt>ByteArray#</tt>
ArrWordsClosure :: !StgInfoTable -> !Word -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Size of array in bytes
[bytes] :: GenClosure b -> !Word

-- | Array payload
[arrWords] :: GenClosure b -> ![Word]

-- | A <tt>MutableByteArray#</tt>
MutArrClosure :: !StgInfoTable -> !Word -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | ?? Closures.h vs ClosureMacros.h
[mccSize] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | An <tt>MVar#</tt>, with a queue of thread state objects blocking on
--   them
MVarClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | A <tt>MutVar#</tt>
MutVarClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to closure
[var] :: GenClosure b -> !b

-- | An STM blocking queue.
BlockingQueueClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b

-- | The blackhole closure
[blackHole] :: GenClosure b -> !b

-- | The owning thread state object
[owner] :: GenClosure b -> !b

-- | ??
[queue] :: GenClosure b -> !b

-- | Primitive Int
IntClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[intVal] :: GenClosure b -> !Int

-- | Primitive Word
WordClosure :: PrimType -> !Word -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[wordVal] :: GenClosure b -> !Word

-- | Primitive Int64
Int64Closure :: PrimType -> !Int64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[int64Val] :: GenClosure b -> !Int64

-- | Primitive Word64
Word64Closure :: PrimType -> !Word64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[word64Val] :: GenClosure b -> !Word64

-- | Primitive Addr
AddrClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[addrVal] :: GenClosure b -> !Int

-- | Primitive Float
FloatClosure :: PrimType -> !Float -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[floatVal] :: GenClosure b -> !Float

-- | Primitive Double
DoubleClosure :: PrimType -> !Double -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[doubleVal] :: GenClosure b -> !Double

-- | Another kind of closure
OtherClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[hvalues] :: GenClosure b -> ![b]
[rawWords] :: GenClosure b -> ![Word]
UnsupportedClosure :: !StgInfoTable -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
data PrimType
PInt :: PrimType
PWord :: PrimType
PInt64 :: PrimType
PWord64 :: PrimType
PAddr :: PrimType
PFloat :: PrimType
PDouble :: PrimType

-- | For generic code, this function returns all referenced closures.
allClosures :: GenClosure b -> [b]

-- | An arbitrary Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <tt>getBoxedClosureData</tt>, the function knows how
--   far it has to evaluate the argument.
data Box
Box :: Any -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list)
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box
instance GHC.Show.Show b => GHC.Show.Show (GHC.Exts.Heap.Closures.GenClosure b)
instance GHC.Show.Show GHC.Exts.Heap.Closures.PrimType
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.PrimType
instance GHC.Show.Show GHC.Exts.Heap.Closures.Box

module GHC.Exts.Heap.Utils
dataConNames :: Ptr StgInfoTable -> IO (String, String, String)


-- | With this module, you can investigate the heap representation of
--   Haskell values, i.e. to investigate sharing and lazy evaluation.
module GHC.Exts.Heap
type Closure = GenClosure Box

-- | This is the representation of a Haskell value on the heap. It reflects
--   <a>http://hackage.haskell.org/trac/ghc/browser/includes/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by the type to store references in.
--   Usually this is a <a>Box</a> with the type synonym <a>Closure</a>.
--   
--   All Heap objects have the same basic layout. A header containing a
--   pointer to the info table and a payload with various fields. The
--   <tt>info</tt> field below always refers to the info table pointed to
--   by the header. The remaining fields are the payload.
--   
--   See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects</a>
--   for more information.
data GenClosure b

-- | A data constructor
ConstrClosure :: !StgInfoTable -> ![b] -> ![Word] -> !String -> !String -> !String -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | Package name
[pkg] :: GenClosure b -> !String

-- | Module name
[modl] :: GenClosure b -> !String

-- | Constructor name
[name] :: GenClosure b -> !String

-- | A function
FunClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk, an expression not obviously in head normal form
ThunkClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk which performs a simple selection operation
SelectorClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to the object being selected from
[selectee] :: GenClosure b -> !b

-- | An unsaturated function application
PAPClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A function application
APClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A suspended thunk evaluation
APStackClosure :: !StgInfoTable -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A pointer to another closure, introduced when a thunk is updated to
--   point at its value
IndClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A byte-code object (BCO) which can be interpreted by GHC's byte-code
--   interpreter (e.g. as used by GHCi)
BCOClosure :: !StgInfoTable -> !b -> !b -> !b -> !HalfWord -> !HalfWord -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A pointer to an ArrWords of instructions
[instrs] :: GenClosure b -> !b

-- | A pointer to an ArrWords of literals
[literals] :: GenClosure b -> !b

-- | A pointer to an ArrWords of byte code objects
[bcoptrs] :: GenClosure b -> !b

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | The size of this BCO in words
[size] :: GenClosure b -> !HalfWord

-- | An StgLargeBitmap describing the pointerhood of its args/free vars
[bitmap] :: GenClosure b -> ![Word]

-- | A thunk under evaluation by another thread
BlackholeClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A <tt>ByteArray#</tt>
ArrWordsClosure :: !StgInfoTable -> !Word -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Size of array in bytes
[bytes] :: GenClosure b -> !Word

-- | Array payload
[arrWords] :: GenClosure b -> ![Word]

-- | A <tt>MutableByteArray#</tt>
MutArrClosure :: !StgInfoTable -> !Word -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | ?? Closures.h vs ClosureMacros.h
[mccSize] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | An <tt>MVar#</tt>, with a queue of thread state objects blocking on
--   them
MVarClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | A <tt>MutVar#</tt>
MutVarClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to closure
[var] :: GenClosure b -> !b

-- | An STM blocking queue.
BlockingQueueClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b

-- | The blackhole closure
[blackHole] :: GenClosure b -> !b

-- | The owning thread state object
[owner] :: GenClosure b -> !b

-- | ??
[queue] :: GenClosure b -> !b

-- | Primitive Int
IntClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[intVal] :: GenClosure b -> !Int

-- | Primitive Word
WordClosure :: PrimType -> !Word -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[wordVal] :: GenClosure b -> !Word

-- | Primitive Int64
Int64Closure :: PrimType -> !Int64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[int64Val] :: GenClosure b -> !Int64

-- | Primitive Word64
Word64Closure :: PrimType -> !Word64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[word64Val] :: GenClosure b -> !Word64

-- | Primitive Addr
AddrClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[addrVal] :: GenClosure b -> !Int

-- | Primitive Float
FloatClosure :: PrimType -> !Float -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[floatVal] :: GenClosure b -> !Float

-- | Primitive Double
DoubleClosure :: PrimType -> !Double -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[doubleVal] :: GenClosure b -> !Double

-- | Another kind of closure
OtherClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[hvalues] :: GenClosure b -> ![b]
[rawWords] :: GenClosure b -> ![Word]
UnsupportedClosure :: !StgInfoTable -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
N_CLOSURE_TYPES :: ClosureType
data PrimType
PInt :: PrimType
PWord :: PrimType
PInt64 :: PrimType
PWord64 :: PrimType
PAddr :: PrimType
PFloat :: PrimType
PDouble :: PrimType
class HasHeapRep (a :: TYPE rep)
getClosureData :: HasHeapRep a => a -> IO Closure

-- | This is a somewhat faithful representation of an info table. See
--   <a>http://hackage.haskell.org/trac/ghc/browser/includes/rts/storage/InfoTables.h</a>
--   for more details on this data structure.
data StgInfoTable
StgInfoTable :: Maybe EntryFunPtr -> HalfWord -> HalfWord -> ClosureType -> HalfWord -> Maybe ItblCodes -> StgInfoTable
[entry] :: StgInfoTable -> Maybe EntryFunPtr
[ptrs] :: StgInfoTable -> HalfWord
[nptrs] :: StgInfoTable -> HalfWord
[tipe] :: StgInfoTable -> ClosureType
[srtlen] :: StgInfoTable -> HalfWord
[code] :: StgInfoTable -> Maybe ItblCodes
type EntryFunPtr = FunPtr (Ptr () -> IO (Ptr ()))
type HalfWord = Word32
type ItblCodes = Either [Word8] [Word32]

-- | Size in bytes of a standard InfoTable
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

-- | Like <a>getClosureData</a>, but taking a <a>Box</a>, so it is easier
--   to work with.
getBoxedClosureData :: Box -> IO Closure

-- | For generic code, this function returns all referenced closures.
allClosures :: GenClosure b -> [b]

-- | An arbitrary Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <tt>getBoxedClosureData</tt>, the function knows how
--   far it has to evaluate the argument.
data Box
Box :: Any -> Box

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list)
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool
instance GHC.Exts.Heap.HasHeapRep a
instance GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Int# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Word# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Int64# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Word64# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Addr# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Float# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Double# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a

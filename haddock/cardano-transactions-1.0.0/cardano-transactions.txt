-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library utilities for constructing and signing Cardano transactions.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/cardano-transactions</a>
@package cardano-transactions
@version 1.0.0

module Data.UTxO.Transaction

-- | Abstract interface for constructing a <i>Payment</i>.
class MkPayment dom where {
    
    -- | Some initial extra data needed to construct and or serialize the
    --   transaction. This is a free-type which is implementation-specific.
    --   
    --   For example, Byron transactions requires the underlying protocol magic
    --   in order to produce witnesses. This is an appropriate place for.
    type family Init dom :: *;
    
    -- | Type representation of transaction <a>Input</a>
    type family Input dom = inp | inp -> dom;
    
    -- | Type representation of transaction <a>Output</a>
    type family Output dom = out | out -> dom;
    
    -- | Type representation of transaction <a>SignKey</a>
    type family SignKey dom = key | key -> dom;
    
    -- | An intermediate type for representing a transaction under
    --   construction. <a>Input</a> and <a>Output</a> can still be added to a
    --   <a>CoinSel</a> and must be added before trying to sign any of the
    --   inputs.
    type family CoinSel dom = sel | sel -> dom;
    
    -- | A transaction is a locked <a>CoinSel</a> to which it is no longer
    --   possible to add new <a>Input</a> and or <a>Output</a>. Only <a>Tx</a>
    --   can be serialized.
    type family Tx dom = tx | tx -> dom;
}
empty :: MkPayment dom => Init dom -> CoinSel dom
addInput :: MkPayment dom => Input dom -> CoinSel dom -> CoinSel dom
addOutput :: MkPayment dom => Output dom -> CoinSel dom -> CoinSel dom
lock :: MkPayment dom => CoinSel dom -> Tx dom
signWith :: MkPayment dom => SignKey dom -> Tx dom -> Tx dom
serialize :: MkPayment dom => Tx dom -> Either ErrMkPayment ByteString

-- | Possible errors occuring when constructing a <i>Payment</i>. This can
--   in practice be safely ignored if the transaction is known to be
--   well-formed.
data ErrMkPayment

-- | Payments must have at least one input.
MissingInput :: ErrMkPayment

-- | Payments must have at least one output
MissingOutput :: ErrMkPayment

-- | Payments must have a signature for each input.
MissingSignature :: ErrMkPayment
instance GHC.Classes.Eq Data.UTxO.Transaction.ErrMkPayment
instance GHC.Read.Read Data.UTxO.Transaction.ErrMkPayment
instance GHC.Show.Show Data.UTxO.Transaction.ErrMkPayment

module Data.UTxO.Transaction.Cardano.Byron

-- | Construct a payment <a>Init</a> for <i>Byron</i> from primitive types.
--   
--   <b>examples</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkInit 764824073 == mainnetMagic
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkInit 1097911063 == testnetMagic
--   True
--   </pre>
mkInit :: Word32 -> Init Byron

-- | Pre-defined <a>Init</a> magic for <i>Byron</i> MainNet.
mainnetMagic :: Init Byron

-- | Pre-defined <a>Init</a> magic for <i>Byron</i> TestNet.
testnetMagic :: Init Byron

-- | Construct a payment <a>Input</a> for <i>Byron</i> from primitive
--   types.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkInput 14 =&lt;&lt; fromBase16 "3b402651...aad1c0b7"
--   Just (Input ...)
--   </pre>
mkInput :: Word32 -> ByteString -> Maybe (Input Byron)

-- | Construct a payment <a>Output</a> for <i>Byron</i> from primitive
--   types.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkOutput 42 =&lt;&lt; fromBase58 "Ae2tdPwU...DnXy319f"
--   Just (Output ...)
--   </pre>
mkOutput :: Natural -> ByteString -> Maybe (Output Byron)

-- | Construct a <a>SignKey</a> for <i>Byron</i> from primitive types.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkSignKey =&lt;&lt; fromBase16 "3b402651...aad1c0b7"
--   Just (SignKey ...)
--   </pre>
mkSignKey :: ByteString -> Maybe (SignKey Byron)
instance Data.UTxO.Transaction.MkPayment Data.UTxO.Transaction.Cardano.Byron.Byron

module Data.UTxO.Transaction.Cardano.Shelley

-- | Construct a payment <a>Init</a> for <i>Shelley</i> from primitive
--   types.
--   
--   <b>examples</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkInit Mainnet 430000
--   
--   &gt;&gt;&gt; mkInit (Testnet (NetworkMagic 1234)) 430000
--   </pre>
mkInit :: NetworkId -> SlotNo -> Fee -> Init Shelley

-- | A type isomorphic to <a>Integer</a> to represent fees.
newtype Fee
Fee :: Integer -> Fee
[unFee] :: Fee -> Integer

-- | Construct a payment <a>Input</a> for <i>Shelley</i> from primitive
--   types.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkInput 14 =&lt;&lt; fromBase16 "3b402651...aad1c0b7"
--   Just (Input ...)
--   </pre>
mkInput :: Word32 -> ByteString -> Maybe (Input Shelley)

-- | Construct a payment <a>Output</a> for <i>Shelley</i> from primitive
--   types.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkOutput 42 =&lt;&lt; fromBase58 "Ae2tdPwU...DnXy319f"
--   
--   &gt;&gt;&gt; mkOutput 42 =&lt;&lt; fromBech32 "addr1sjc...6s3xvu5g"
--   
--   &gt;&gt;&gt; mkOutput 42 =&lt;&lt; fromBase16 "42bf330c...ba5b947e"
--   Just (Output ...)
--   </pre>
mkOutput :: Natural -> ByteString -> Maybe (Output Shelley)

-- | Construct a <a>SignKey</a> for <i>Shelley</i> from primitive types.
--   This is for Shelley era keys.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkShelleySignKey =&lt;&lt; fromBech32 "xprv13f0ve...nu4v4h875l"
--   Just (SignKey ...)
--   </pre>
mkShelleySignKey :: ByteString -> Maybe (SignKey Shelley)

-- | Construct a <a>SignKey</a> for <i>Shelley</i> from primitive types.
--   This is for Byron era keys.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; let (Just addr) = fromBase58 "DdzFFzCqrh...Dwg3SiaHiEL"
--   
--   &gt;&gt;&gt; mkByronSignKey addr =&lt;&lt; fromBech32 "xprv13f0ve...nu4v4h875l"
--   Just (SignKey ...)
--   </pre>
mkByronSignKey :: AddrAttributes -> ByteString -> Maybe (SignKey Shelley)

-- | Extract address attributes from an address, if they exists (i.e. if
--   the address is a bootstrap / Byron address).
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; let (Just addr) = fromBase58 "DdzFFzCqrh...Dwg3SiaHiEL"
--   
--   &gt;&gt;&gt; mkAddrAttributes addr
--   Just (AddrAttributes ...)
--   </pre>
mkAddrAttributes :: ByteString -> Maybe AddrAttributes
instance GHC.Num.Num Data.UTxO.Transaction.Cardano.Shelley.Fee
instance GHC.Classes.Eq Data.UTxO.Transaction.Cardano.Shelley.Fee
instance GHC.Show.Show Data.UTxO.Transaction.Cardano.Shelley.Fee
instance Data.UTxO.Transaction.MkPayment Data.UTxO.Transaction.Cardano.Shelley.Shelley
